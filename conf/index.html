
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouAreInControl Chat</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/libsodium-wrappers/0.5.4/sodium.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5-qrcode/2.3.8/html5-qrcode.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        /* Mirror local video */
        #local-video {
            transform: scaleX(-1);
        }
        /* Profile image styling */
        .profile-img {
            width: 3.5rem;
            height: 3.5rem;
            border-radius: 50%;
            object-fit: cover;
        }
        /* Messenger-like chat bubble tweak */
        .chat-bubble {
            border-radius: 20px;
            max-width: 60%;
            margin: 4px 0;
            word-wrap: break-word;
        }
        .incoming .chat-bubble {
            border-bottom-left-radius: 4px;
            background: #f0f0f0;
        }
        .outgoing .chat-bubble {
            border-bottom-right-radius: 4px;
            background: #0084ff;
            color: white;
        }
        .contact-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-radius: 8px;
            transition: all 0.2s;
            cursor: pointer;
        }
        .contact-item:hover {
            background-color: rgba(0,0,0,0.05);
        }
        .contact-item.active {
            background-color: rgba(0,132,255,0.1);
        }
        .messenger-input {
            background: #f0f2f5;
            border-radius: 20px;
            padding: 8px 12px;
            margin: 0 8px;
            flex-grow: 1;
        }
        .messenger-input:focus {
            outline: none;
            box-shadow: none;
        }
        .sidebar {
            width: 320px;
            border-right: 1px solid #e4e6eb;
        }
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .message-timestamp {
            font-size: 11px;
            margin-top: 4px;
            opacity: 0.7;
        }
        /* Add responsive styles */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: -100%;
                top: 0;
                bottom: 0;
                width: 100%;
                z-index: 50;
                transition: left 0.3s ease;
            }
            .sidebar.active {
                left: 0;
            }
            .chat-container {
                width: 100%;
            }
            .mobile-nav {
                display: flex;
                padding: 1rem;
                align-items: center;
                justify-content: space-between;
                background: white;
                border-bottom: 1px solid #e4e6eb;
            }
            .mobile-nav.dark {
                background: #1f2937;
                border-color: #374151;
            }
            #user-info {
                max-width: 100%;
                overflow: hidden;
                word-break: break-all;
            }
            #qr-code img {
                max-width: 200px;
                margin: 0 auto;
            }
        }

        .modal {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 1rem;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 1rem;
            width: 100%;
            max-width: 400px;
            text-align: center;
        }

        .dark .modal-content {
            background: #1f2937;
        }

        /* Telegram-like styles */
        .telegram-sidebar {
            width: 320px;
            background: #fff;
            display: flex;
            flex-direction: column;
        }

        .telegram-header {
            padding: 16px;
            background: #2b5278;
            color: white;
        }

        .telegram-search {
            padding: 12px 16px;
            background: #f5f5f5;
            border-bottom: 1px solid #e5e5e5;
        }

        .contact-item {
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: all 0.2s;
            border-bottom: 1px solid #f0f0f0;
        }

        .contact-item:hover {
            background: #f5f5f5;
        }

        .contact-item.active {
            background: #e3f2fd;
        }

        .chat-container {
            display: flex;
            flex-direction: column;
            background: #eee;
        }

        .chat-header {
            background: #fff;
            border-bottom: 1px solid #e5e5e5;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .chat-messages {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            background: #e7e7e7;
        }

        .chat-input-container {
            background: #fff;
            padding: 12px 16px;
            border-top: 1px solid #e5e5e5;
        }

        .message-bubble {
            max-width: 70%;
            padding: 8px 12px;
            border-radius: 12px;
            margin: 4px 0;
        }

        .message-outgoing {
            background: #2b5278;
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 4px;
        }

        .message-incoming {
            background: white;
            border-bottom-left-radius: 4px;
        }

        /* Mobile styles */
        @media (max-width: 768px) {
            .telegram-sidebar {
                position: fixed;
                left: -100%;
                top: 0;
                bottom: 0;
                width: 100%;
                z-index: 50;
                transition: left 0.3s ease;
            }

            .telegram-sidebar.active {
                left: 0;
            }

            .mobile-header {
                display: flex;
                padding: 12px 16px;
                background: #2b5278;
                color: white;
                align-items: center;
                justify-content: space-between;
            }

            .chat-container {
                width: 100%;
                height: 100vh;
            }
        }

        /* Dark mode */
        .dark .telegram-sidebar,
        .dark .chat-header,
        .dark .chat-input-container {
            background: #1f2937;
            border-color: #374151;
        }

        .dark .contact-item {
            border-color: #374151;
        }

        .dark .contact-item:hover {
            background: #374151;
        }

        .dark .contact-item.active {
            background: #2b5278;
            color: white;
        }

        .dark .chat-container {
            background: #111827;
        }

        .dark .message-incoming {
            background: #374151;
            color: white;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100">
    <div id="loading-screen" class="fixed inset-0 flex items-center justify-center bg-white dark:bg-gray-900">
        <div class="text-2xl">Loading...</div>
    </div>

    <div id="app" class="min-h-screen hidden">
        <div id="setup-screen" class="fixed inset-0 flex items-center justify-center bg-white dark:bg-gray-900 p-4">
            <div class="p-6 bg-white dark:bg-gray-800 rounded-xl shadow-xl max-w-md w-full">
                <h2 class="text-3xl font-bold mb-6 text-center">Welcome to Chat</h2>
                <input type="text" id="display-name" placeholder="Enter your display name" class="w-full p-4 mb-6 border rounded-lg text-lg dark:bg-gray-700 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                <button id="start-btn" class="w-full py-4 bg-blue-500 text-white text-lg font-semibold rounded-lg hover:bg-blue-600 transition-colors">Start Messaging</button>
            </div>
        </div>

        <div id="main-screen" class="hidden h-screen flex">
            <!-- Mobile header -->
            <div class="mobile-header md:hidden">
                <button id="menu-toggle" class="text-white">
                    <i class="fas fa-bars"></i>
                </button>
                <h1 class="text-lg font-semibold">WorkChat</h1>
                <button id="mobile-qr-btn" class="text-white">
                    <i class="fas fa-qrcode"></i>
                </button>
            </div>

            <!-- Sidebar -->
            <div class="telegram-sidebar">
                <div class="telegram-header">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-3">
                            <img id="profile-picture" class="profile-img" />
                            <div>
                                <div id="user-name" class="font-semibold"></div>
                                <button id="share-id-btn" class="text-sm opacity-80 hover:opacity-100">
                                    Share ID <i class="fas fa-share-alt ml-1"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="telegram-search">
                    <div class="relative">
                        <input type="text" id="peer-id" 
                            class="w-full px-4 py-2 bg-gray-100 dark:bg-gray-700 rounded-full text-sm"
                            placeholder="Search or enter user ID" />
                        <button id="connect-btn" class="absolute right-2 top-1/2 transform -translate-y-1/2 text-blue-500">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                    <button id="scan-qr-btn" class="mt-2 w-full flex items-center gap-2 text-sm text-blue-500 p-2">
                        <i class="fas fa-qrcode"></i>
                        <span>Scan QR Code</span>
                    </button>
                </div>

                <div id="contact-list" class="flex-1 overflow-y-auto"></div>
            </div>

            <!-- Chat area -->
            <div class="chat-container flex-1">
                <div id="chat-header" class="p-4 border-b flex items-center justify-between bg-white dark:bg-gray-800">
                    <div class="flex items-center gap-3">
                        <img id="chat-profile" class="w-10 h-10 rounded-full" />
                        <div>
                            <h2 id="chat-title" class="font-semibold">Select a contact</h2>
                            <div id="typing-indicator" class="text-sm text-gray-500"></div>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button id="audio-call-btn" class="hidden p-2 text-gray-600 hover:bg-gray-100 rounded-full">
                            <i class="fas fa-phone"></i>
                        </button>
                        <button id="video-call-btn" class="hidden p-2 text-gray-600 hover:bg-gray-100 rounded-full">
                            <i class="fas fa-video"></i>
                        </button>
                    </div>
                </div>

                <div id="chat-messages" class="flex-1 p-4 space-y-2 overflow-y-auto bg-white dark:bg-gray-800"></div>

                <div id="chat-input" class="p-4 bg-white dark:bg-gray-800 border-t">
                    <div class="flex items-center">
                        <button id="attach-btn" class="p-2 text-gray-600 hover:bg-gray-100 rounded-full">
                            <i class="fas fa-paperclip"></i>
                        </button>
                        <input type="text" id="message-input" placeholder="Aa" 
                            class="messenger-input dark:bg-gray-700" />
                        <button id="send-btn" class="p-2 text-blue-500 hover:bg-gray-100 rounded-full">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div id="qr-scanner-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-xl max-w-lg w-full p-6">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold">Scan QR Code</h3>
                    <button id="close-scanner-btn" class="text-2xl hover:text-gray-600 dark:hover:text-gray-400">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div id="qr-reader" class="rounded-lg overflow-hidden"></div>
            </div>
        </div>

        <div id="call-modal" class="hidden fixed inset-0 bg-black flex flex-col">
            <div id="remote-video-container" class="flex-1 relative">
                <video id="remote-video" class="w-full h-full object-cover" autoplay></video>
                <div id="local-video-container" class="absolute bottom-4 right-4 w-1/4 aspect-video rounded-lg overflow-hidden shadow-lg">
                    <video id="local-video" class="w-full h-full object-cover" autoplay muted></video>
                </div>
            </div>
            <div class="p-6 flex justify-center items-center gap-6 bg-black bg-opacity-50">
                <button id="toggle-audio-btn" class="p-4 bg-gray-600 text-white rounded-full hover:bg-gray-700 transition-colors">
                    <i class="fas fa-microphone"></i>
                </button>
                <button id="toggle-video-btn" class="p-4 bg-gray-600 text-white rounded-full hover:bg-gray-700 transition-colors">
                    <i class="fas fa-video"></i>
                </button>
                <button id="end-call-btn" class="p-4 bg-red-500 text-white rounded-full hover:bg-red-600 transition-colors">
                    <i class="fas fa-phone-slash"></i>
                </button>
            </div>
        </div>

        <div id="incoming-call-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-xl p-6 max-w-sm w-full text-center">
                <h3 class="text-xl font-bold mb-4">Incoming Call</h3>
                <p id="caller-id" class="mb-6"></p>
                <div class="flex justify-center gap-4">
                    <button id="accept-call-btn" class="p-4 bg-green-500 text-white rounded-full hover:bg-green-600 transition-colors">
                        <i class="fas fa-phone"></i>
                    </button>
                    <button id="reject-call-btn" class="p-4 bg-red-500 text-white rounded-full hover:bg-red-600 transition-colors">
                        <i class="fas fa-phone-slash"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add mobile nav bar -->
    <div class="mobile-nav md:hidden">
        <button id="menu-toggle" class="p-2 rounded-full hover:bg-gray-100">
            <i class="fas fa-bars"></i>
        </button>
        <div class="text-lg font-semibold">Chat</div>
        <button id="show-qr-btn" class="p-2 rounded-full hover:bg-gray-100">
            <i class="fas fa-qrcode"></i>
        </button>
    </div>

    <!-- Add QR code modal -->
    <div id="qr-modal" class="modal">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold">Share Your Chat ID</h3>
                <button class="close-modal p-2">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div id="modal-qr-code" class="mb-6"></div>
            <div class="text-left p-4 bg-gray-50 dark:bg-gray-800 rounded-lg">
                <p class="text-sm text-gray-500 mb-2">Your Chat ID</p>
                <div id="modal-user-id" class="font-mono text-sm break-all cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 p-2 rounded"></div>
                <p class="text-xs text-gray-500 mt-2">Click to copy</p>
            </div>
        </div>
    </div>

    <script>
class CryptoService {
    constructor() {
        this.keyPair = null;
        this.publicKey = null;
        this.privateKey = null;
    }

    async initialize() {
        await sodium.ready;
        const storedKeyPair = localStorage.getItem('keyPair');
        
        if (storedKeyPair) {
            this.keyPair = JSON.parse(storedKeyPair);
            this.publicKey = sodium.from_base64(this.keyPair.publicKey);
            this.privateKey = sodium.from_base64(this.keyPair.privateKey);
        } else {
            const keyPair = sodium.crypto_box_keypair();
            this.publicKey = keyPair.publicKey;
            this.privateKey = keyPair.privateKey;
            
            this.keyPair = {
                publicKey: sodium.to_base64(this.publicKey),
                privateKey: sodium.to_base64(this.privateKey)
            };
            
            localStorage.setItem('keyPair', JSON.stringify(this.keyPair));
        }
    }

    async encrypt(message, recipientPublicKey) {
        const nonce = sodium.randombytes_buf(sodium.crypto_box_NONCEBYTES);
        const encryptedMessage = sodium.crypto_box_easy(
            sodium.from_string(message),
            nonce,
            sodium.from_base64(recipientPublicKey),
            this.privateKey
        );
        
        return {
            encrypted: sodium.to_base64(encryptedMessage),
            nonce: sodium.to_base64(nonce)
        };
    }

    async decrypt(encryptedData, senderPublicKey) {
        const decrypted = sodium.crypto_box_open_easy(
            sodium.from_base64(encryptedData.encrypted),
            sodium.from_base64(encryptedData.nonce),
            sodium.from_base64(senderPublicKey),
            this.privateKey
        );
        
        return sodium.to_string(decrypted);
    }

    async encryptFile(file) {
        const arrayBuffer = await file.arrayBuffer();
        const nonce = sodium.randombytes_buf(sodium.crypto_secretbox_NONCEBYTES);
        const key = sodium.randombytes_buf(sodium.crypto_secretbox_KEYBYTES);
        
        const encrypted = sodium.crypto_secretbox_easy(
            new Uint8Array(arrayBuffer),
            nonce,
            key
        );
        
        return {
            encrypted: sodium.to_base64(encrypted),
            nonce: sodium.to_base64(nonce),
            key: sodium.to_base64(key),
            filename: file.name,
            type: file.type,
            size: file.size
        };
    }

    async decryptFile(encryptedData) {
        const decrypted = sodium.crypto_secretbox_open_easy(
            sodium.from_base64(encryptedData.encrypted),
            sodium.from_base64(encryptedData.nonce),
            sodium.from_base64(encryptedData.key)
        );
        
        return new File([decrypted], encryptedData.filename, { type: encryptedData.type });
    }
}

class StorageService {
    constructor() {
        this.db = null;
    }

    async initialize() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('youareincontrol-chat', 2);
            
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve();
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('messages')) {
                    db.createObjectStore('messages', { keyPath: 'id', autoIncrement: true });
                }
                if (!db.objectStoreNames.contains('calls')) {
                    db.createObjectStore('calls', { keyPath: 'id', autoIncrement: true });
                }
            };
        });
    }

    async saveMessage(message) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['messages'], 'readwrite');
            const store = transaction.objectStore('messages');
            const request = store.add(message);
            
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    async getMessages(peerId) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['messages'], 'readonly');
            const store = transaction.objectStore('messages');
            const request = store.getAll();
            
            request.onsuccess = () => {
                const messages = request.result.filter(m => 
                    m.sender === peerId || m.recipient === peerId
                );
                resolve(messages);
            };
            request.onerror = () => reject(request.error);
        });
    }

    async saveCall(call) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['calls'], 'readwrite');
            const store = transaction.objectStore('calls');
            const request = store.add(call);
            
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }
}

class CallManager {
    constructor() {
        this.localStream = null;
        this.remoteStream = null;
        this.currentCall = null;
        this.isAudioEnabled = true;
        this.isVideoEnabled = true;
        this.ringtone = new Audio('https://www.soundjay.com/free-music/midnight-ride-01a.mp3');
        this.ringtone.loop = true;
    }

    async startLocalStream(videoEnabled = true) {
        try {
            // First try with both video and audio
            this.localStream = await navigator.mediaDevices.getUserMedia({
                video: videoEnabled,
                audio: true
            });
        } catch (error) {
            console.warn('Failed to get video: ', error);
            if (videoEnabled) {
                try {
                    // If video fails, try audio only
                    this.localStream = await navigator.mediaDevices.getUserMedia({
                        video: false,
                        audio: true
                    });
                } catch (audioError) {
                    console.error('Failed to get audio: ', audioError);
                    throw new Error('Could not access microphone or camera. Please check your device permissions.');
                }
            } else {
                throw error;
            }
        }

        if (this.localStream) {
            const videoElement = document.getElementById('local-video');
            if (videoElement) {
                videoElement.srcObject = this.localStream;
            }
        }
        return this.localStream;
    }

    stopLocalStream() {
        if (this.localStream) {
            this.localStream.getTracks().forEach(track => track.stop());
            this.localStream = null;
        }
        document.getElementById('local-video').srcObject = null;
    }

    setRemoteStream(stream) {
        this.remoteStream = stream;
        document.getElementById('remote-video').srcObject = stream;
    }

    toggleAudio() {
        if (this.localStream) {
            const audioTrack = this.localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                this.isAudioEnabled = audioTrack.enabled;
                document.getElementById('toggle-audio-btn').innerHTML = 
                    `<i class="fas fa-microphone${audioTrack.enabled ? '' : '-slash'}"></i>`;
            }
        }
    }

    toggleVideo() {
        if (this.localStream) {
            const videoTrack = this.localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                this.isVideoEnabled = videoTrack.enabled;
                document.getElementById('toggle-video-btn').innerHTML = 
                    `<i class="fas fa-video${videoTrack.enabled ? '' : '-slash'}"></i>`;
            }
        }
    }

    endCall() {
        if (this.currentCall) {
            this.currentCall.close();
            this.currentCall = null;
        }
        this.stopLocalStream();
        document.getElementById('call-modal').classList.add('hidden');
        document.getElementById('remote-video').srcObject = null;
    }

    startRingtone() {
        this.ringtone.play().catch(console.error);
    }

    stopRingtone() {
        this.ringtone.pause();
        this.ringtone.currentTime = 0;
    }

    async handleIncomingCall(call) {
        const callerName = this.connections.get(call.peer)?.metadata?.displayName || call.peer;
        document.getElementById('caller-id').textContent = `${callerName} is calling...`;
        document.getElementById('incoming-call-modal').classList.remove('hidden');
        this.startRingtone();

        const handleAccept = async () => {
            this.stopRingtone();
            try {
                const stream = await this.callManager.startLocalStream(call.metadata?.videoEnabled);
                call.answer(stream);
                this.setupCall(call);
                document.getElementById('incoming-call-modal').classList.add('hidden');
                document.getElementById('call-modal').classList.remove('hidden');
            } catch (error) {
                alert('Failed to access camera/microphone');
                call.close();
            }
        };

        const handleReject = () => {
            this.stopRingtone();
            call.close();
            document.getElementById('incoming-call-modal').classList.add('hidden');
        };

        document.getElementById('accept-call-btn').onclick = handleAccept;
        document.getElementById('reject-call-btn').onclick = handleReject;
    }
}

class P2PService {
    constructor() {
        this.peer = null;
        this.connections = new Map();
        this.callManager = new CallManager();
        this.callbacks = {
            onMessage: null,
            onConnection: null,
            onDisconnection: null,
            onCall: null,
            onTyping: null
        };
        this.currentUserId = null;  // Add this line
    }

    async initialize() {
        const userId = localStorage.getItem('userId') || this.generateUserId();
        localStorage.setItem('userId', userId);
        this.currentUserId = userId;  // Store userId in the service
        
        return new Promise((resolve, reject) => {
            this.peer = new Peer(userId, {
                config: {
                    iceServers: [
                        { urls: "stun:stun.l.google.com:19302" },
                        { urls: "stun:stun.l.google.com:5349" },
                        { urls: "stun:stun1.l.google.com:3478" },
                        { urls: "stun:stun1.l.google.com:5349" },
                        { urls: "stun:stun2.l.google.com:19302" },
                        { urls: "stun:stun2.l.google.com:5349" },
                        { urls: "stun:stun3.l.google.com:3478" },
                        { urls: "stun:stun3.l.google.com:5349" },
                        { urls: "stun:stun4.l.google.com:19302" },
                        { urls: "stun:stun4.l.google.com:5349" }
                    ]
                }
            });
            
            this.peer.on('open', () => {
                this.setupPeerEvents();
                resolve(userId);
            });
            
            this.peer.on('error', async (err) => {
                if (err.type === 'unavailable-id' && !this._retryAttempted) {
                    console.warn('Collision encountered, regenerating ID...');
                    this._retryAttempted = true;
                    const newId = this.generateUserId();
                    localStorage.setItem('userId', newId);
                    try {
                        resolve(await this.initialize());
                    } catch (error) {
                        reject(error);
                    }
                } else {
                    console.error('Peer ID collision or other error:', err);
                    reject(err);
                }
            });
        });
    }

    setupPeerEvents() {
        this.peer.on('connection', this.handleConnection.bind(this));
        this.peer.on('call', this.handleIncomingCall.bind(this));
    }

    generateUserId() {
        const array = new Uint8Array(24);
        self.crypto.getRandomValues(array);
        const randomHex = Array.from(array, b => b.toString(16).padStart(2, '0')).join('');
        return `user-${randomHex}`;
    }

    async handleConnection(conn) {
        await this.setupConnection(conn);
    }

    async connect(peerId) {
        if (this.connections.has(peerId)) return;
        
        const conn = this.peer.connect(peerId, {
            reliable: true,
            serialization: 'json',
            metadata: {
                publicKey: cryptoService.keyPair.publicKey,
                displayName: localStorage.getItem('displayName')
            }
        });
        
        await this.setupConnection(conn);
        return conn;
    }

    async setupConnection(conn) {
        return new Promise((resolve) => {
            conn.on('open', () => {
                // Send our display name with the key exchange
                const myDisplayName = localStorage.getItem('displayName');
                conn.send({
                    type: 'key-exchange',
                    publicKey: cryptoService.keyPair.publicKey,
                    displayName: myDisplayName
                });
                
                this.connections.set(conn.peer, conn);
                this.callbacks.onConnection?.(conn.peer, conn.metadata?.displayName);
                resolve();
            });

            conn.on('data', this.handleDataMessage.bind(this, conn));

            conn.on('close', () => {
                this.connections.delete(conn.peer);
                this.callbacks.onDisconnection?.(conn.peer);
            });
        });
    }

    async handleDataMessage(conn, data) {
        if (data.type === 'key-exchange') {
            conn.metadata = {
                publicKey: data.publicKey,
                displayName: data.displayName
            };
            
            // Update contact display if exists
            const contactElement = document.querySelector(`[data-peer-id="${conn.peer}"]`);
            if (contactElement) {
                const nameElement = contactElement.querySelector('.font-semibold');
                if (nameElement) {
                    nameElement.textContent = data.displayName || conn.peer;
                }
                const profileImg = contactElement.querySelector('img');
                if (profileImg) {
                    profileImg.src = `https://api.dicebear.com/9.x/fun-emoji/svg?seed=${encodeURIComponent(data.displayName || conn.peer)}`;
                }
            }
        } else if (data.type === 'message') {
            const decrypted = await cryptoService.decrypt(
                data.content,
                data.senderPublicKey
            );
            const message = {
                sender: conn.peer,
                content: decrypted,
                timestamp: data.timestamp,
                displayName: conn.metadata?.displayName
            };
            this.callbacks.onMessage?.(message);
            await storageService.saveMessage({
                sender: conn.peer,
                recipient: this.peer.id,
                content: decrypted,
                timestamp: data.timestamp,
                displayName: conn.metadata?.displayName
            });
        } else if (data.type === 'typing') {
            this.callbacks.onTyping?.({
                sender: conn.peer,
                isTyping: data.isTyping,
                displayName: conn.metadata?.displayName
            });
        }
    }

    async sendMessage(peerId, message) {
        const conn = this.connections.get(peerId);
        if (!conn || !conn.metadata?.publicKey) return false;
        
        const encrypted = await cryptoService.encrypt(
            message,
            conn.metadata.publicKey
        );
        
        conn.send({
            type: 'message',
            content: encrypted,
            senderPublicKey: cryptoService.keyPair.publicKey,
            timestamp: Date.now()
        });
        
        await storageService.saveMessage({
            sender: 'me',
            recipient: peerId,
            content: message,
            timestamp: Date.now(),
            displayName: localStorage.getItem('displayName')
        });
        
        return true;
    }

    async startCall(peerId, videoEnabled = true) {
        try {
            const stream = await this.callManager.startLocalStream(videoEnabled);
            const call = this.peer.call(peerId, stream, {
                metadata: { videoEnabled }
            });
            this.setupCall(call);
            document.getElementById('call-modal').classList.remove('hidden');
            return call;
        } catch (error) {
            this.callManager.stopLocalStream();
            throw error;
        }
    }

    async handleIncomingCall(call) {
        const callerName = this.connections.get(call.peer)?.metadata?.displayName || call.peer;
        document.getElementById('caller-id').textContent = `${callerName} is calling...`;
        document.getElementById('incoming-call-modal').classList.remove('hidden');
        this.callManager.startRingtone();

        const handleAccept = async () => {
            this.callManager.stopRingtone();
            try {
                const stream = await this.callManager.startLocalStream(call.metadata?.videoEnabled);
                call.answer(stream);
                this.setupCall(call);
                document.getElementById('incoming-call-modal').classList.add('hidden');
                document.getElementById('call-modal').classList.remove('hidden');
            } catch (error) {
                alert('Failed to access camera/microphone');
                call.close();
            }
        };

        const handleReject = () => {
            this.callManager.stopRingtone();
            call.close();
            document.getElementById('incoming-call-modal').classList.add('hidden');
        };

        document.getElementById('accept-call-btn').onclick = handleAccept;
        document.getElementById('reject-call-btn').onclick = handleReject;
    }

    setupCall(call) {
        this.callManager.currentCall = call;

        call.on('stream', (remoteStream) => {
            this.callManager.setRemoteStream(remoteStream);
            this.callbacks.onCall?.({
                peer: call.peer,
                stream: remoteStream
            });
        });

        call.on('close', () => {
            this.callManager.endCall();
        });

        document.getElementById('toggle-audio-btn').onclick = () => {
            this.callManager.toggleAudio();
        };

        document.getElementById('toggle-video-btn').onclick = () => {
            this.callManager.toggleVideo();
        };

        document.getElementById('end-call-btn').onclick = () => {
            this.callManager.endCall();
        };
    }
}

function setupQRScanner() {
    const html5QrcodeScanner = new Html5Qrcode("qr-reader");
    
    document.getElementById('scan-qr-btn').onclick = async () => {
        const modal = document.getElementById('qr-scanner-modal');
        modal.classList.remove('hidden');
        
        try {
            await html5QrcodeScanner.start(
                { facingMode: "environment" },
                { fps: 10, qrbox: 250 },
                async (decodedText) => {
                    try {
                        await html5QrcodeScanner.stop();
                        modal.classList.add('hidden');
                        document.getElementById('peer-id').value = decodedText;
                        document.getElementById('connect-btn').click();
                    } catch (error) {
                        console.warn('Error stopping scanner:', error);
                    }
                },
                (error) => console.warn(error)
            );
        } catch (error) {
            console.error('QR Scanner error:', error);
            alert('Could not start camera. Please check your permissions.');
            modal.classList.add('hidden');
        }
    };
}

function setupUI() {
    setupQRScanner();
    setupEventListeners();
    setupCallbacks();
    const displayName = localStorage.getItem('displayName') || 'username';
    const profileUrl = `https://api.dicebear.com/9.x/fun-emoji/svg?seed=${encodeURIComponent(displayName)}`;
    document.getElementById('profile-picture').src = profileUrl;
}

function setupEventListeners() {
    // Check for existing display name
    const savedDisplayName = localStorage.getItem('displayName');
    if (savedDisplayName) {
        document.getElementById('setup-screen').classList.add('hidden');
        document.getElementById('main-screen').classList.remove('hidden');
        document.getElementById('user-name').textContent = savedDisplayName;
    }

    document.getElementById('start-btn').onclick = () => {
        const displayName = document.getElementById('display-name').value.trim();
        if (displayName) {
            localStorage.setItem('displayName', displayName);
            document.getElementById('user-name').textContent = displayName;
            document.getElementById('setup-screen').classList.add('hidden');
            document.getElementById('main-screen').classList.remove('hidden');
            
            // Update profile picture
            const profileUrl = `https://api.dicebear.com/9.x/fun-emoji/svg?seed=${encodeURIComponent(displayName)}`;
            document.getElementById('profile-picture').src = profileUrl;
        } else {
            alert('Please enter a display name');
        }
    };

    document.getElementById('connect-btn').onclick = async () => {
        const peerId = document.getElementById('peer-id').value.trim();
        if (peerId) {
            try {
                await p2pService.connect(peerId);
                document.getElementById('peer-id').value = '';
            } catch (error) {
                alert('Failed to connect to peer. Please check the ID and try again.');
            }
        }
    };

    document.getElementById('send-btn').onclick = sendMessage;
    document.getElementById('message-input').onkeyup = handleMessageInput;
    document.getElementById('message-input').oninput = handleTypingIndicator;
    document.getElementById('attach-btn').onclick = handleFileAttachment;
    document.getElementById('audio-call-btn').onclick = () => startCall(false);
    document.getElementById('video-call-btn').onclick = () => startCall(true);
}

function handleMessageInput(event) {
    if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
    }
}

function handleTypingIndicator() {
    if (currentPeer) {
        const conn = p2pService.connections.get(currentPeer);
        if (conn) {
            conn.send({
                type: 'typing',
                isTyping: true
            });
            
            clearTimeout(window.typingTimeout);
            window.typingTimeout = setTimeout(() => {
                conn.send({
                    type: 'typing',
                    isTyping: false
                });
            }, 1000);
        }
    }
}

async function handleFileAttachment() {
    const input = document.createElement('input');
    input.type = 'file';
    input.onchange = async () => {
        const file = input.files[0];
        if (file && currentPeer) {
            try {
                const progressElement = addProgressIndicator();
                const encryptedFile = await cryptoService.encryptFile(file);
                await p2pService.sendMessage(currentPeer, JSON.stringify({
                    type: 'file',
                    data: encryptedFile
                }));
                progressElement.remove();
                addFileToChat('outgoing', file);
            } catch (error) {
                alert('Failed to send file. Please try again.');
            }
        }
    };
    input.click();
}

function addProgressIndicator() {
    const progressContainer = document.createElement('div');
    progressContainer.className = 'flex justify-end mb-4';
    
    const progressBar = document.createElement('div');
    progressBar.className = 'bg-gray-200 rounded-full h-2.5 w-48';
    progressBar.innerHTML = '<div class="bg-blue-500 h-2.5 rounded-full w-full animate-pulse"></div>';
    
    progressContainer.appendChild(progressBar);
    document.getElementById('chat-messages').appendChild(progressContainer);
    return progressContainer;
}

async function startCall(videoEnabled) {
    if (currentPeer) {
        try {
            await p2pService.startCall(currentPeer, videoEnabled);
        } catch (error) {
            alert('Failed to start call. Please check your camera/microphone permissions.');
        }
    }
}

function setupCallbacks() {
    p2pService.callbacks.onConnection = (peerId, displayName) => {
        const contactList = document.getElementById('contact-list');
        const existingContact = document.querySelector(`[data-peer-id="${peerId}"]`);
        
        if (!existingContact) {
            const contactElement = document.createElement('div');
            contactElement.className = 'contact-item';
            contactElement.dataset.peerId = peerId;
            
            // Get peer's display name from connection metadata
            const peerConnection = p2pService.connections.get(peerId);
            const peerDisplayName = peerConnection?.metadata?.displayName || displayName || peerId;
            
            contactElement.innerHTML = `
                <img src="https://api.dicebear.com/9.x/fun-emoji/svg?seed=${encodeURIComponent(peerDisplayName)}" 
                    class="w-12 h-12 rounded-full mr-3" />
                <div>
                    <div class="font-semibold">${peerDisplayName}</div>
                    <div class="text-sm text-gray-500 truncate">${peerId}</div>
                </div>
            `;
            
            contactElement.onclick = () => {
                document.querySelectorAll('.contact-item').forEach(el => el.classList.remove('active'));
                contactElement.classList.add('active');
                selectPeer(peerId, peerDisplayName);
            };
            
            contactList.appendChild(contactElement);
        }
    };
    // ...rest of the callbacks
}

function selectPeer(peerId, displayName) {
    currentPeer = peerId;
    const connection = p2pService.connections.get(peerId);
    const peerDisplayName = connection?.metadata?.displayName || displayName || peerId;
    
    // Update chat header
    document.getElementById('chat-title').textContent = peerDisplayName;
    document.getElementById('chat-profile').src = 
        `https://api.dicebear.com/9.x/fun-emoji/svg?seed=${encodeURIComponent(peerDisplayName)}`;
    
    // Show chat controls
    document.getElementById('chat-messages').innerHTML = '';
    document.getElementById('audio-call-btn').classList.remove('hidden');
    document.getElementById('video-call-btn').classList.remove('hidden');
    
    // On mobile, close sidebar after selection
    if (window.innerWidth <= 768) {
        document.querySelector('.telegram-sidebar')?.classList.remove('active');
    }
    
    loadMessages(peerId);
}

async function loadMessages(peerId) {
    const messages = await storageService.getMessages(peerId);
    messages.sort((a, b) => a.timestamp - b.timestamp).forEach(message => {
        const type = message.sender === 'me' ? 'outgoing' : 'incoming';
        try {
            const content = JSON.parse(message.content);
            if (content.type === 'file') {
                addFileToChat(type, content.data);
            } else {
                addMessageToChat(type, message);
            }
        } catch {
            addMessageToChat(type, message);
        }
    });
    scrollToBottom();
}

function sendMessage() {
    const input = document.getElementById('message-input');
    const message = input.value.trim();
    
    if (message && currentPeer) {
        p2pService.sendMessage(currentPeer, message)
            .then(success => {
                if (success) {
                    addMessageToChat('outgoing', {
                        content: message,
                        timestamp: Date.now(),
                        displayName: localStorage.getItem('displayName')
                    });
                    input.value = '';
                    scrollToBottom();
                }
            })
            .catch(() => alert('Failed to send message. Please try again.'));
    }
}

function addMessageToChat(type, message) {
    const messagesContainer = document.getElementById('chat-messages');
    const messageElement = document.createElement('div');
    messageElement.className = `flex ${type === 'outgoing' ? 'justify-end' : 'justify-start'} mb-1`;
    
    const bubble = document.createElement('div');
    bubble.className = `chat-bubble ${type}`;
    
    const content = document.createElement('div');
    content.className = 'px-3 py-2';
    content.textContent = message.content;
    
    const timestamp = document.createElement('div');
    timestamp.className = 'message-timestamp px-3 pb-1';
    timestamp.textContent = new Date(message.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    
    bubble.appendChild(content);
    bubble.appendChild(timestamp);
    messageElement.appendChild(bubble);
    messagesContainer.appendChild(messageElement);
}

function addFileToChat(type, file) {
    const messagesContainer = document.getElementById('chat-messages');
    const messageElement = document.createElement('div');
    messageElement.className = `flex ${type === 'outgoing' ? 'justify-end' : 'justify-start'} mb-4`;
    
    const bubble = document.createElement('div');
    bubble.className = `max-w-[70%] p-3 rounded-lg chat-bubble ${
        type === 'outgoing' 
            ? 'bg-blue-500 text-white rounded-br-none' 
            : 'bg-gray-200 dark:bg-gray-700 rounded-bl-none'
    }`;

    if (file.type?.startsWith('image/')) {
        const img = document.createElement('img');
        img.src = URL.createObjectURL(file);
        img.className = 'max-w-full rounded-lg cursor-pointer';
        img.onclick = () => window.open(img.src, '_blank');
        bubble.appendChild(img);
    } else {
        const link = document.createElement('a');
        link.href = URL.createObjectURL(file);
        link.download = file.name;
        link.className = 'flex items-center gap-2 text-current no-underline';
        link.innerHTML = `
            <i class="fas fa-file"></i>
            <span class="break-all">${file.name}</span>
        `;
        bubble.appendChild(link);
    }
    
    messageElement.appendChild(bubble);
    messagesContainer.appendChild(messageElement);
    scrollToBottom();
}

function scrollToBottom() {
    const messagesContainer = document.getElementById('chat-messages');
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// Add this helper function at the start of your script
function getElement(id) {
    const element = document.getElementById(id);
    if (!element) {
        throw new Error(`Element with id "${id}" not found`);
    }
    return element;
}

// Add mobile UI handlers
function setupMobileUI() {
    try {
        const menuToggle = document.getElementById('menu-toggle');
        const sidebar = document.querySelector('.telegram-sidebar'); // Update selector
        const showQrBtn = document.getElementById('show-qr-btn');
        const shareIdBtn = document.getElementById('share-id-btn');
        const qrModal = document.getElementById('qr-modal');
        const closeButtons = document.querySelectorAll('.close-modal');
        
        if (menuToggle && sidebar) {
            menuToggle.onclick = () => sidebar.classList.toggle('active');
        }

        // Set up QR buttons
        [showQrBtn, shareIdBtn].forEach(btn => {
            if (btn) {
                btn.onclick = showQRModal;
            }
        });

        // Set up close buttons
        closeButtons.forEach(btn => {
            if (btn) {
                btn.onclick = (e) => {
                    const modal = e.target.closest('.modal');
                    if (modal) modal.classList.remove('active');
                };
            }
        });

        // Set up click-to-copy
        const modalUserId = document.getElementById('modal-user-id');
        if (modalUserId) {
            modalUserId.onclick = async () => {
                try {
                    await navigator.clipboard.writeText(modalUserId.textContent);
                    const originalText = modalUserId.textContent;
                    modalUserId.innerHTML = '<span class="text-green-500">✓ Copied!</span>';
                    setTimeout(() => {
                        modalUserId.textContent = originalText;
                    }, 1500);
                } catch (err) {
                    console.error('Failed to copy:', err);
                }
            };
        }

        // Close sidebar on outside click
        document.addEventListener('click', (e) => {
            if (window.innerWidth <= 768 && 
                sidebar?.classList.contains('active') && 
                !sidebar.contains(e.target) && 
                !menuToggle?.contains(e.target)) {
                sidebar.classList.remove('active');
            }
        });
    } catch (error) {
        console.error('Mobile UI setup error:', error);
    }
}

// Add showQRModal function
function showQRModal() {
    try {
        const qrModal = getElement('qr-modal');
        const modalUserId = getElement('modal-user-id');
        const modalQrCode = getElement('modal-qr-code');
        
        // Get userId from p2pService or localStorage
        const userId = p2pService.currentUserId || localStorage.getItem('userId');
        
        if (!userId) {
            throw new Error('User ID not found');
        }

        qrModal.classList.add('active');
        modalUserId.textContent = userId;
        
        // Clear and regenerate QR code
        modalQrCode.innerHTML = '';
        new QRCode(modalQrCode, {
            text: userId,
            width: 200,
            height: 200,
            colorDark: '#2b5278',
            colorLight: '#ffffff',
            correctLevel: QRCode.CorrectLevel.H
        });
    } catch (error) {
        console.error('Failed to show QR modal:', error);
        alert('Could not display QR code. Please try again.');
    }
}

// Update initialize function
async function initialize() {
    try {
        // First wait for DOM to be ready
        await new Promise(resolve => {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', resolve);
            } else {
                resolve();
            }
        });

        // Then initialize services
        await sodium.ready;
        await cryptoService.initialize();
        await storageService.initialize();
        const userId = await p2pService.initialize();

        // Now safely access DOM elements
        const loadingScreen = getElement('loading-screen');
        const appContainer = getElement('app');
        
        try {
            // Try to set up user ID and QR code if those elements exist
            const userIdElement = document.getElementById('user-id');
            const qrCodeElement = document.getElementById('qr-code');
            
            if (userIdElement && qrCodeElement) {
                userIdElement.textContent = userId;
                new QRCode(qrCodeElement, userId);
            }

            // Set up display name if element exists
            const displayNameInput = document.getElementById('display-name');
            const displayName = localStorage.getItem('displayName');
            if (displayNameInput && displayName) {
                displayNameInput.value = displayName;
            }

            // Show main app
            loadingScreen.classList.add('hidden');
            appContainer.classList.remove('hidden');

            setupUI();
            setupMobileUI();
        } catch (error) {
            console.warn('Some UI elements could not be initialized:', error);
            // Continue anyway as core functionality might still work
            loadingScreen.classList.add('hidden');
            appContainer.classList.remove('hidden');
        }
    } catch (error) {
        console.error('Fatal initialization error:', error);
        alert('Failed to initialize the application:\n' + (error.message || error));
    }
}

// Update window.onload to use the new initialize function
document.addEventListener('DOMContentLoaded', initialize);
// Remove the existing window.addEventListener('load', initialize);

const cryptoService = new CryptoService();
const storageService = new StorageService();
const p2pService = new P2PService();
let currentPeer = null;

    </script>
</body>
</html>
